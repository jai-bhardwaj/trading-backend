"""
Base Strategy Framework for Algorithmic Trading

This module provides the foundation for implementing trading strategies
across different asset classes (equity, derivatives, commodities, crypto).
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Union
from enum import Enum
import logging
from datetime import datetime
from app.utils.timezone_utils import ist_utcnow as datetime_now

logger = logging.getLogger(__name__)

class SignalType(Enum):
    """Types of trading signals"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"

class AssetClass(Enum):
    """Supported asset classes"""
    EQUITY = "EQUITY"
    DERIVATIVES = "DERIVATIVES"
    COMMODITIES = "COMMODITIES"
    CRYPTO = "CRYPTO"
    FOREX = "FOREX"

class TimeFrame(Enum):
    """Trading timeframes"""
    TICK = "TICK"
    MINUTE_1 = "1m"
    MINUTE_5 = "5m"
    MINUTE_15 = "15m"
    HOUR_1 = "1h"
    HOUR_4 = "4h"
    DAILY = "1d"
    WEEKLY = "1w"

@dataclass
class MarketData:
    """Market data structure"""
    symbol: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    asset_class: AssetClass
    exchange: str
    additional_data: Dict[str, Any] = field(default_factory=dict)

@dataclass
class StrategySignal:
    """Trading signal generated by strategy"""
    signal_type: SignalType
    symbol: str
    confidence: float  # 0.0 to 1.0
    quantity: Optional[int] = None
    price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime_now)

@dataclass
class StrategyResult:
    """Result of strategy execution"""
    success: bool
    message: str
    orders_placed: int
    pnl: float
    orders: List[Any] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime_now)

@dataclass
class StrategyConfig:
    """Strategy configuration"""
    name: str
    asset_class: AssetClass
    symbols: List[str]
    timeframe: TimeFrame
    parameters: Dict[str, Any]
    risk_parameters: Dict[str, Any]
    is_active: bool = True
    paper_trade: bool = False

class BaseStrategy(ABC):
    """
    Base class for all trading strategies
    
    This provides a template that can be extended for different asset classes
    and trading approaches while maintaining consistency.
    """
    
    def __init__(self, config: StrategyConfig):
        self.config = config
        self.name = config.name
        self.asset_class = config.asset_class
        self.symbols = config.symbols
        self.timeframe = config.timeframe
        self.parameters = config.parameters
        self.risk_parameters = config.risk_parameters
        self.is_active = config.is_active
        self.paper_trade = config.paper_trade
        
        # Strategy state
        self.positions: Dict[str, Dict[str, Any]] = {}
        self.historical_data: Dict[str, List[MarketData]] = {}
        self.performance_metrics: Dict[str, float] = {}
        
        # Initialize strategy-specific components
        self.initialize()
    
    @abstractmethod
    def initialize(self) -> None:
        """Initialize strategy-specific components"""
        pass
    
    @abstractmethod
    def process_market_data(self, market_data: MarketData) -> Optional[StrategySignal]:
        """
        Process market data and generate trading signals
        
        Args:
            market_data: Current market data
            
        Returns:
            StrategySignal if a signal is generated, None otherwise
        """
        pass
    
    @abstractmethod
    def calculate_position_size(self, signal: StrategySignal, current_balance: float) -> int:
        """
        Calculate position size based on risk management rules
        
        Args:
            signal: Trading signal
            current_balance: Current account balance
            
        Returns:
            Position size (number of shares/contracts)
        """
        pass
    
    def validate_signal(self, signal: StrategySignal) -> bool:
        """
        Validate trading signal against risk rules
        
        Args:
            signal: Trading signal to validate
            
        Returns:
            True if signal is valid, False otherwise
        """
        try:
            # Basic validation
            if not signal.symbol or signal.confidence < 0 or signal.confidence > 1:
                return False
            
            # Check if symbol is in allowed list
            if signal.symbol not in self.symbols:
                logger.warning(f"Signal for {signal.symbol} not in allowed symbols")
                return False
            
            # Asset class specific validation
            return self._validate_asset_class_specific(signal)
            
        except Exception as e:
            logger.error(f"Error validating signal: {e}")
            return False
    
    def _validate_asset_class_specific(self, signal: StrategySignal) -> bool:
        """Asset class specific validation - can be overridden"""
        return True
    
    def update_position(self, symbol: str, quantity: int, price: float, side: str) -> None:
        """Update position tracking"""
        if symbol not in self.positions:
            self.positions[symbol] = {
                'quantity': 0,
                'average_price': 0.0,
                'unrealized_pnl': 0.0,
                'realized_pnl': 0.0
            }
        
        position = self.positions[symbol]
        
        if side == 'BUY':
            # Calculate new average price
            total_quantity = position['quantity'] + quantity
            if total_quantity > 0:
                total_value = (position['quantity'] * position['average_price']) + (quantity * price)
                position['average_price'] = total_value / total_quantity
            position['quantity'] = total_quantity
        elif side == 'SELL':
            # Calculate realized P&L
            if position['quantity'] > 0:
                realized_pnl = quantity * (price - position['average_price'])
                position['realized_pnl'] += realized_pnl
            position['quantity'] -= quantity
    
    def calculate_unrealized_pnl(self, current_prices: Dict[str, float]) -> float:
        """Calculate unrealized P&L for all positions"""
        total_pnl = 0.0
        
        for symbol, position in self.positions.items():
            if symbol in current_prices and position['quantity'] != 0:
                current_price = current_prices[symbol]
                unrealized_pnl = position['quantity'] * (current_price - position['average_price'])
                position['unrealized_pnl'] = unrealized_pnl
                total_pnl += unrealized_pnl
        
        return total_pnl
    
    def get_performance_metrics(self) -> Dict[str, float]:
        """Get strategy performance metrics"""
        total_realized_pnl = sum(pos['realized_pnl'] for pos in self.positions.values())
        total_unrealized_pnl = sum(pos['unrealized_pnl'] for pos in self.positions.values())
        
        self.performance_metrics.update({
            'total_realized_pnl': total_realized_pnl,
            'total_unrealized_pnl': total_unrealized_pnl,
            'total_pnl': total_realized_pnl + total_unrealized_pnl,
            'active_positions': len([p for p in self.positions.values() if p['quantity'] != 0])
        })
        
        return self.performance_metrics
    
    def add_historical_data(self, market_data: MarketData) -> None:
        """Add market data to historical buffer"""
        symbol = market_data.symbol
        if symbol not in self.historical_data:
            self.historical_data[symbol] = []
        
        self.historical_data[symbol].append(market_data)
        
        # Keep only last N data points (configurable)
        max_history = self.parameters.get('max_history_length', 1000)
        if len(self.historical_data[symbol]) > max_history:
            self.historical_data[symbol] = self.historical_data[symbol][-max_history:]
    
    def get_historical_data(self, symbol: str, lookback: int = None) -> List[MarketData]:
        """Get historical data for symbol"""
        if symbol not in self.historical_data:
            return []
        
        data = self.historical_data[symbol]
        if lookback:
            return data[-lookback:]
        return data
    
    def should_process_data(self, market_data: MarketData) -> bool:
        """Check if strategy should process this market data"""
        # Check if strategy is active
        if not self.is_active:
            return False
        
        # Check if symbol is in strategy's symbol list
        if market_data.symbol not in self.symbols:
            return False
        
        # Check asset class match
        if market_data.asset_class != self.asset_class:
            return False
        
        return True
    
    def get_strategy_info(self) -> Dict[str, Any]:
        """Get strategy information"""
        return {
            'name': self.name,
            'asset_class': self.asset_class.value,
            'symbols': self.symbols,
            'timeframe': self.timeframe.value,
            'is_active': self.is_active,
            'paper_trade': self.paper_trade,
            'parameters': self.parameters,
            'risk_parameters': self.risk_parameters,
            'positions': self.positions,
            'performance_metrics': self.get_performance_metrics()
        }
    
    def __str__(self) -> str:
        return f"{self.__class__.__name__}({self.name}, {self.asset_class.value})"
